qq <- seq(0, 1, 0.01)
va <- rep(5, length(pp))
vb <- 1:length(pp)
library(PoissonBinomial)
qgpbinom(qq, pp, va, vb)
sum(pmin(va, vb))
sum(pmax(va, vb))
va <- -va
sum(pmax(va, vb))
sum(pmin(va, vb))
qgpbinom(qq, pp, va, vb)
PoissonBinomial:::transform.GPB(NULL, pp, va, vb, rep(1, 10))
PoissonBinomial:::transform.GPB(NULL, pp, va, vb, rep(1, 15))
qgpbinom(qq, pp, va, vb, lower.tail = FALSE)
library(PoissonBinomial)
qgpbinom(qq, pp, va, vb, lower.tail = FALSE)
library(PoissonBinomial)
qgpbinom(qq, pp, va, vb, lower.tail = FALSE)
qgpbinom(qq, pp, va, vb, lower.tail = TRUE)
PoissonBinomial:::transform.GPB(NULL, pp, va, vb, rep(1, 15))
devtools::check_win_devel()
detach("package:PoissonBinomial", unload = TRUE)
install.packages("D:/Nextcloud/R/PoissonBinomial_1.2.2.tar.gz", repos = NULL, type = "source")
install.packages("D:/Nextcloud/R/PoissonBinomial_1.2.2.tar.gz", repos = NULL, type = "source")
devtools::release()
devtools::spell_check()
devtools::release()
install.packages(c("pbkrtest", "RcppArmadillo", "waldo", "xfun", "zoo"))
log2(4530)
log2(4530/2265)
ceiling(log2(4530/2265))
ceiling(log2(4531/2265))
ceiling(log2(2265/2265))
ceiling(log2(2266/2265))
require(ggplot2)
require(openxlsx)
path <- "D:/Nextcloud/R/GPB Benchmarks/"
n <- c(25000 * 4:1, 2500 * 8:1, 500 * 4:1, 250, 100)
sizes <- c(250000 * 8:1, 50000 * 4:1, 25000, 10000, 7500, 5000)
splits <- 0:10
res <- NULL
for(j in 1:length(sizes)){
idx.n <- which(n <= sizes[j])
if(length(idx.n)){
load(paste(path, "bench_dftcf_", sizes[j], ".RData", sep = ""))
rownames(results) <- NULL
res <- rbind(res, cbind(splits = NA, N = n[idx.n], size = sizes[j], results))
}
}
for(i in 1:length(splits)){
for(j in 1:length(sizes)){
idx.n <- which(n <= sizes[j])
if(length(idx.n)){
load(paste(path, "bench_", sizes[j], "_", splits[i], ".RData", sep = ""))
rownames(results) <- NULL
res <- rbind(res, cbind(splits = splits[i], N = n[idx.n], size = sizes[j], results))
}
}
}
res$splits <- as.factor(res$splits)
idx.NA <- which(is.na(res[1]))
res.dftcf <- res[idx.NA, c(2:3, 6, 7)]
res.dcfft <- res[-idx.NA, c(1:3, 6, 7)] #res[-idx.NA, c(1:3, 6, 7)]
best.split <- sapply(sizes, function(s) sapply(n, function(k) {tab <- subset(res, size == s & N == k)$median
return(ifelse(length(tab) > 0, which.min(tab) - 2, NA))}))
best.time <- sapply(sizes, function(s) sapply(n, function(k) {best <- subset(res, size == s & N == k)$median
if(length(best)) return(min(best)) else return(NA)}))
data <- data.frame(size = rep(sizes, rep(length(n), length(sizes))), N = n, M = as.vector(best.split))
t1 <- function(t = 600){
fitted.splits <- sapply(sizes, function(s) sapply(n, function(k) pmax(0, round(log2(k / t)))))
fitted.time <- sapply(1:length(sizes), function(i) sapply(1:length(n), function(j) {as.numeric(subset(res, size == sizes[i] & N == n[j] & splits == fitted.splits[j, i], median))}))
ds <- matrix(data$M, length(n), length(sizes)) - fitted.splits
dt <- fitted.time - best.time
ft <- fitted.time / best.time - 1
#prods <- outer(n, sizes)
dtw <- dt * n
ftw <- ft * n
res <- numeric(12)
res[ 1] <- sum(abs(ds), na.rm = TRUE)
res[ 2] <- sum(ds, na.rm = TRUE)
res[ 3] <- sum(ds != 0, na.rm = TRUE)
#res[ 4] <- min(dt, na.rm = TRUE)/1000
res[ 4] <- max(dt, na.rm = TRUE)/1000
res[ 5] <- sum(dt, na.rm = TRUE)/1000
#res[ 7] <- min(ft, na.rm = TRUE)*100
res[ 6] <- max(ft, na.rm = TRUE)*100
res[ 7] <- sum(ft, na.rm = TRUE)*100
res[ 8] <- (sum(fitted.time, na.rm = TRUE) / sum(best.time, na.rm = TRUE) - 1)*100
res[ 9] <- max(dtw, na.rm = TRUE)/100000
res[10] <- sum(dtw, na.rm = TRUE)/100000
res[11] <- max(ftw, na.rm = TRUE)/1000
res[12] <- sum(ftw, na.rm = TRUE)/1000
return(res)
}
t1 <- function(t = 600){
fitted.splits <- sapply(sizes, function(s) sapply(n, function(k) pmax(0, ceiling(log2(k / t)))))
fitted.time <- sapply(1:length(sizes), function(i) sapply(1:length(n), function(j) {as.numeric(subset(res, size == sizes[i] & N == n[j] & splits == fitted.splits[j, i], median))}))
ds <- matrix(data$M, length(n), length(sizes)) - fitted.splits
dt <- fitted.time - best.time
ft <- fitted.time / best.time - 1
#prods <- outer(n, sizes)
dtw <- dt * n
ftw <- ft * n
res <- numeric(12)
res[ 1] <- sum(abs(ds), na.rm = TRUE)
res[ 2] <- sum(ds, na.rm = TRUE)
res[ 3] <- sum(ds != 0, na.rm = TRUE)
#res[ 4] <- min(dt, na.rm = TRUE)/1000
res[ 4] <- max(dt, na.rm = TRUE)/1000
res[ 5] <- sum(dt, na.rm = TRUE)/1000
#res[ 7] <- min(ft, na.rm = TRUE)*100
res[ 6] <- max(ft, na.rm = TRUE)*100
res[ 7] <- sum(ft, na.rm = TRUE)*100
res[ 8] <- (sum(fitted.time, na.rm = TRUE) / sum(best.time, na.rm = TRUE) - 1)*100
res[ 9] <- max(dtw, na.rm = TRUE)/100000
res[10] <- sum(dtw, na.rm = TRUE)/100000
res[11] <- max(ftw, na.rm = TRUE)/1000
res[12] <- sum(ftw, na.rm = TRUE)/1000
return(res)
}
t <- 1000
fitted.splits <- sapply(sizes, function(s) sapply(n, function(k) pmax(0, ceiling(log2(k / t)))))
fitted.time <- sapply(1:length(sizes), function(i) sapply(1:length(n), function(j) {as.numeric(subset(res, size == sizes[i] & N == n[j] & splits == fitted.splits[j, i], median))}))
ds <- matrix(data$M, length(n), length(sizes)) - fitted.splits
dt <- fitted.time - best.time
ft <- fitted.time / best.time - 1
#prods <- outer(n, sizes)
dtw <- dt * n
dtw
t1 <- function(t = 600){
fitted.splits <- sapply(sizes, function(s) sapply(n, function(k) pmax(0, ceiling(log2(k / t)))))
fitted.time <- sapply(1:length(sizes), function(i) sapply(1:length(n), function(j) {as.numeric(subset(res, size == sizes[i] & N == n[j] & splits == fitted.splits[j, i], median))}))
ds <- matrix(data$M, length(n), length(sizes)) - fitted.splits
dt <- fitted.time - best.time
ft <- fitted.time / best.time - 1
#prods <- outer(n, sizes)
dtw <- dt * n
ftw <- ft * n
result <- numeric(12)
result[ 1] <- sum(abs(ds), na.rm = TRUE)
result[ 2] <- sum(ds, na.rm = TRUE)
result[ 3] <- sum(ds != 0, na.rm = TRUE)
#result[ 4] <- min(dt, na.rm = TRUE)/1000
result[ 4] <- max(dt, na.rm = TRUE)/1000
result[ 5] <- sum(dt, na.rm = TRUE)/1000
#result[ 7] <- min(ft, na.rm = TRUE)*100
result[ 6] <- max(ft, na.rm = TRUE)*100
result[ 7] <- sum(ft, na.rm = TRUE)*100
result[ 8] <- (sum(fitted.time, na.rm = TRUE) / sum(best.time, na.rm = TRUE) - 1)*100
result[ 9] <- max(dtw, na.rm = TRUE)/100000
result[10] <- sum(dtw, na.rm = TRUE)/100000
result[11] <- max(ftw, na.rm = TRUE)/1000
result[12] <- sum(ftw, na.rm = TRUE)/1000
return(result)
}
m1 <- sapply(101:3000, function(t) t1(t))
t1 <- function(t = 600){
fitted.splits <- sapply(sizes, function(s) sapply(n, function(k) pmax(0, ceiling(log2(k / t)))))
fitted.time <- sapply(1:length(sizes), function(i) sapply(1:length(n), function(j) {as.numeric(subset(res, size == sizes[i] & N == n[j] & splits == fitted.splits[j, i], median))}))
ds <- matrix(data$M, length(n), length(sizes)) - fitted.splits
dt <- fitted.time - best.time
ft <- fitted.time / best.time - 1
#prods <- outer(n, sizes)
dtw <- dt / n
ftw <- ft * n
result <- numeric(12)
result[ 1] <- sum(abs(ds), na.rm = TRUE)
result[ 2] <- sum(ds, na.rm = TRUE)
result[ 3] <- sum(ds != 0, na.rm = TRUE)
#result[ 4] <- min(dt, na.rm = TRUE)/1000
result[ 4] <- max(dt, na.rm = TRUE)/1000
result[ 5] <- sum(dt, na.rm = TRUE)/1000
#result[ 7] <- min(ft, na.rm = TRUE)*100
result[ 6] <- max(ft, na.rm = TRUE)*100
result[ 7] <- sum(ft, na.rm = TRUE)*100
result[ 8] <- (sum(fitted.time, na.rm = TRUE) / sum(best.time, na.rm = TRUE) - 1)*100
result[ 9] <- max(dtw, na.rm = TRUE)*100000
result[10] <- sum(dtw, na.rm = TRUE)*100000
result[11] <- max(ftw, na.rm = TRUE)/1000
result[12] <- sum(ftw, na.rm = TRUE)/1000
return(result)
}
m1 <- sapply(101:3000, function(t) t1(t))
which(m1[ 1, ] == min(m1[ 1, ])) + 100
which(m1[ 3, ] == min(m1[ 3, ])) + 100
which(abs(m1[ 2, ]) == min(abs(m1[2, ]))) + 100
which(m1[ 7, ] == min(m1[ 7, ])) + 100
which(m1[11, ] == min(m1[11, ])) + 100
which(m1[12, ] == min(m1[12, ])) + 100
which(m1[ 4, ] == min(m1[ 4, ])) + 100
which(m1[ 5, ] == min(m1[ 5, ])) + 100
which(m1[12, ] == min(m1[12, ])) + 100
which(m1[10, ] == min(m1[10, ])) + 100
which(m1[ 8, ] == min(m1[ 8, ])) + 100
which(m1[10, ] == min(m1[10, ])) + 100
which(m1[12, ] == min(m1[12, ])) + 100
which(m1[ 7, ] == min(m1[ 7, ])) + 100
which(m1[10, ] == min(m1[10, ])) + 100
which(m1[11, ] == min(m1[11, ])) + 100
which(abs(m1[ 2, ]) == min(abs(m1[2, ]))) + 100
which(m1[ 1, ] == min(m1[ 1, ])) + 100
which(m1[ 3, ] == min(m1[ 3, ])) + 100
which(m1[ 4, ] == min(m1[ 4, ])) + 100
which(m1[ 5, ] == min(m1[ 5, ])) + 100
which(m1[ 8, ] == min(m1[ 8, ])) + 100
which(m1[12, ] == min(m1[12, ])) + 100
which(m1[11, ] == min(m1[11, ])) + 100
which(m1[10, ] == min(m1[10, ])) + 100
which(abs(m1[ 2, ]) == min(abs(m1[2, ]))) + 100
which(m1[ 7, ] == min(m1[ 7, ])) + 100
which(m1[ 1, ] == min(m1[ 1, ])) + 100
which(m1[ 3, ] == min(m1[ 3, ])) + 100
which(abs(m1[ 2, ]) == min(abs(m1[2, ]))) + 100
which(m1[ 7, ] == min(m1[ 7, ])) + 100
which(m1[10, ] == min(m1[10, ])) + 100
which(m1[ 1, ] == min(m1[ 1, ])) + 100
which(m1[ 3, ] == min(m1[ 3, ])) + 100
which(m1[10, ] == min(m1[10, ])) + 100
which(abs(m1[ 2, ]) == min(abs(m1[2, ]))) + 100
which(m1[ 7, ] == min(m1[ 7, ])) + 100
which(m1[11, ] == min(m1[11, ])) + 100
which(m1[ 4, ] == min(m1[ 4, ])) + 100
which(m1[ 5, ] == min(m1[ 5, ])) + 100
which(m1[ 8, ] == min(m1[ 8, ])) + 100
which(m1[12, ] == min(m1[12, ])) + 100
which(abs(m1[ 2, ]) == min(abs(m1[2, ]))) + 100
which(m1[ 7, ] == min(m1[ 7, ])) + 100
which(m1[ 9, ] == min(m1[ 9, ])) + 100
which(m1[ 9, ] == min(m1[ 9, ])) + 100
which(m1[10, ] == min(m1[10, ])) + 100
which(m1[12, ] == min(m1[12, ])) + 100
which(m1[ 6, ] == min(m1[ 6, ])) + 100
which(m1[ 4, ] == min(m1[ 4, ])) + 100
which(m1[ 5, ] == min(m1[ 5, ])) + 100
which(m1[10, ] == min(m1[10, ])) + 100
which(m1[11, ] == min(m1[11, ])) + 100
which(m1[10, ] == min(m1[10, ])) + 100
which(m1[ 1, ] == min(m1[ 1, ])) + 100
which(m1[ 3, ] == min(m1[ 3, ])) + 100
which(m1[ 9, ] == min(m1[ 9, ])) + 100
which(m1[10, ] == min(m1[10, ])) + 100
mean(.Last.value)
t1(960)
min(m1[ 1, ])
min(m1[ 3, ])
min(m1[ 9, ])
which(m1[ 1, ] == min(m1[ 1, ])) + 100
t1(860)
t1 <- function(t = 600){
fitted.splits <- sapply(sizes, function(s) sapply(n, function(k) pmax(0, ceiling(log2(k / t)))))
fitted.time <- sapply(1:length(sizes), function(i) sapply(1:length(n), function(j) {as.numeric(subset(res, size == sizes[i] & N == n[j] & splits == fitted.splits[j, i], median))}))
ds <- matrix(data$M, length(n), length(sizes)) - fitted.splits
dt <- fitted.time - best.time
ft <- fitted.time / best.time - 1
#prods <- outer(n, sizes)
dtw <- dt / n
ftw <- ft * n
result <- numeric(12)
result[ 1] <- sum(abs(ds), na.rm = TRUE)
result[ 2] <- sum(ds, na.rm = TRUE)
result[ 3] <- sum(ds != 0, na.rm = TRUE)
#result[ 4] <- min(dt, na.rm = TRUE)/1000
result[ 4] <- max(dt, na.rm = TRUE)/1000
result[ 5] <- sum(dt, na.rm = TRUE)/1000
#result[ 7] <- min(ft, na.rm = TRUE)*100
result[ 6] <- max(ft, na.rm = TRUE)*100
result[ 7] <- sum(ft, na.rm = TRUE)*100
result[ 8] <- (sum(fitted.time, na.rm = TRUE) / sum(best.time, na.rm = TRUE) - 1)*100
result[ 9] <- max(dtw, na.rm = TRUE)*1000
result[10] <- sum(dtw, na.rm = TRUE)*1000
result[11] <- max(ftw, na.rm = TRUE)/1000
result[12] <- sum(ftw, na.rm = TRUE)/1000
return(result)
}
t1(860)
which(m1[11, ] == min(m1[11, ])) + 100
min(m1[11, ])
t <- 860
fitted.splits <- sapply(sizes, function(s) sapply(n, function(k) pmax(0, ceiling(log2(k / t)))))
fitted.time <- sapply(1:length(sizes), function(i) sapply(1:length(n), function(j) {as.numeric(subset(res, size == sizes[i] & N == n[j] & splits == fitted.splits[j, i], median))}))
ds <- matrix(data$M, length(n), length(sizes)) - fitted.splits
dt <- fitted.time - best.time
ft <- fitted.time / best.time - 1
ds
dt
dt/n * 1000
which(m1[11, ] == min(m1[11, ])) + 100
which(m1[12, ] == min(m1[12, ])) + 100
devtools::check_win_release()
devtools::check_win_release()
devtools::check_win_oldrelease()
devtools::check_win_devel()
install.packages("D:/Nextcloud/R/PoissonBinomial_1.2.2-3.tar.gz", repos = NULL, type = "source", lib="D:/Documents/R/win-library/4.0")
rhub::check_on_solaris()
rhub::check_with_sanitizers(show_status = FALSE)
rhub::check_with_valgrind(show_status = FALSE)
rhub::check_for_cran(show_status = FALSE)
devtools::release()
devtools::spell_check()
devtools::spell_check()
devtools::release()
cut(rnorm(100))
cut(rnorm(100), c(1, 2, 3))
cut(rnorm(100), c(-Inf, 1, 2, 3))
cut(rnorm(100), c(-Inf, 0, 1, 2))
cut(rnorm(100), c(-Inf, 0, 1, 2, Inf))
str(cut(rnorm(100), c(-Inf, 0, 1, 2, Inf)))
str(cut(rnorm(100), c(-Inf, 0, Inf), c("klein", "groß")))
cut(rnorm(100), c(-Inf, 0, Inf), c("klein", "groß"))
x <- recordPlot()
hist(rnorm(100))
x <- recordPlot()
hist(rnorm(2000))
x
replayPlot(x)
hist(rnorm(2000))
replayPlot(x)
hist(rnorm(2000))
replayPlot(x)
x
set.seed(1)
x1 <- rnorm(100)
x2 <- rnorm(100, 0.1)
x3 <- rnorm(100, 1)
x4 <- rnorm(100, 0, 2)
x5 <- rnorm(100, 0.1, 2)
x6 <- rnorm(100, 1, 2)
x7 <- x1 * 2
x8 <- x1 * 1.05 + 0.05
x9 <- x7 - 1
y1 <- trunc(rexp(200)) + 0.5
y2 <- trunc(rexp(200)) + 0.6
y3 <- trunc(rexp(200)) + 1
y4 <- y1 * 1.05
y5 <- y4 + 0.2
y6 <- y1 * 2 + 1
require(BSDA)
tst <- SIGN.test(x1, md = 0)
tst
str(tst)
tst$p.value
tst$conf.int
tst <- SIGN.test(y1, md = 0)
tst
tst <- SIGN.test(y1, md = 0.4)
tst
tst <- SIGN.test(y1, y2)
tst
x1
y1
unique(y1)
quantile(y1, seq(0, 1, 0.05))
tst <- SIGN.test(y1, md = 1.5)
tst
tst <- SIGN.test(y1, md = 0.4)
tst
tst <- SIGN.test(y1, md = 0.5)
tst
median(y1)
tst <- SIGN.test(y1, md = 0.4)
tst
tst <- SIGN.test(y1, md = 0.6)
tst
tst <- SIGN.test(y1, md = 0.5)
tst
wilcox.test(y1)
wilcox.test(y1, mu = 0.5)
wilcox.test(y1, mu = 0.6)
mean(y1)
median(y1)
wilcox.test(y1, mu = 1)
wilcox.test(y1, mu = 0.7)
wilcox.test(y1, mu = 0.8)
wilcox.test(y1, mu = 0.)
wilcox.test(y1, mu = 0.9)
wilcox.test(y1, mu = 1)
x <- replicate(1000, median(y[sample(1:length(y1), 100)]))
x <- replicate(1000, median(y1[sample(1:length(y1), 100)]))
x
hist(x)
table(x)
x <- replicate(10000, median(y1[sample(1:length(y1), 100, TRUE)]))
table(x)
x <- replicate(10000, median(y1[sample(1:length(y1), 100, FALSE)]))
table(x)
table(x)
table(x)
table(x)
x <- replicate(10000, median(y1[sample(1:length(y1), 100, FALSE)]))
table(x)
z.test(x3)
z.test(x3, sigma.x = 1)
z.test(x2, sigma.x = 1)
t.test(x2, mu = 0)
tst <- binom.test(40, 100, 0.5)
tst
str(tst)
tst$p.value
tst$conf.int
binom.test(6, 10, 0.3)
tst$conf.int
tst$p.value
binom.test(6, 10, 0.3)
tst <- z.test(40, alternative = "two.sided", md = p.test, sigma.x = sqrt(p.test * (1 - p.test)))
tst <- z.test(40, alternative = "two.sided", mu = p.test, sigma.x = sqrt(p.test * (1 - p.test)))
p.test <- 0.5
tst <- z.test(40, alternative = "two.sided", mu = p.test, sigma.x = sqrt(p.test * (1 - p.test)))
z.test(x1, alternative = "two.sided", mu = 0, sigma.x = 1)
z.test(x1, alternative = "two.sided", mu = 1, sigma.x = 1)
z.test(x1, alternative = "less", mu = 0, sigma.x = 1)
z.test(x1, alternative = "greater", mu = 0, sigma.x = 1)
z.test(x1, x2, alternative = "two.sided", sigma.x = 1, sigma.y = 1)
z.test(x1, x3, mu = 1, alternative = "two.sided", sigma.x = 1, sigma.y = 2)
z.test(x1, x3, mu = 1, alternative = "two.sided", sigma.x = 1, sigma.y = 1)
t.test(x1, alternative = "two.sided", mu = 0)
t.test(x1, alternative = "two.sided", mu = 1)
t.test(x1, alternative = "less", mu = 0)
t.test(x1, alternative = "greater", mu = 0)
t.test(x1, x2, mu = 1, alternative = "two.sided", var.equal = TRUE)
t.test(x1, x3, alternative = "two.sided", var.equal = TRUE)
XY <- read.xlsx("XY.xlsx")
XY <- read.xlsx("D:/Nextcloud/CCSOR/Kurse/R/SS21/Aufgaben/XY.xlsx")
require(openxlsx)
XY <- read.xlsx("D:/Nextcloud/CCSOR/Kurse/R/SS21/Aufgaben/XY.xlsx")
X <- XY$X
Y <- XY$Y
t.test(X, mu = 0)
t.test(X, mu = 1)
t.test(X, mu = 2)
wilcox.test(Y, mu = 54)
wilcox.test(Y, mu = 55)
wilcox.test(Y, mu = 56)
require(DescTools)
VarTest(X, sigma.squared = 0.5)
VarTest(X, sigma.squared = 1)
VarTest(X, Y, ratio = 1/2500, alternative = "greater") # ratio = 1/2500, weil var(X) <= var(Y/50) = var(Y)/2500
VarTest(Y, X, ratio = 2500, alternative = "less")
###   (e)
shapiro.test(X)
shapiro.test(Y)
X
Y
hist(X)
hist(Y)
var(X)
var(>)
var(Y)
var(X)/var(Y)
var(Y)/var(X)
tst <- binom.test(5, 10, 0.5)
tst$statistic
tst$parameter
tst$estimate
choose(7, 0:7)
choose(6, 0:6)
choose(4, 0:4)
choose(4, 0:4)*4
choose(2, 0:2)*8
choose(2, 0:2)*10
now()
install.packages("lubridate")
lubridate::now()
gsub(lubridate::now(), ":", "-")
gsub(":", "-", lubridate::now())
gsub(":", "-", lubridate::now())
gsub(":", "-", lubridate::now())
gsub(":", "-", lubridate::now())
gsub(":", "-", lubridate::now())
gsub(":", "-", lubridate::now())
gsub(":", "-", lubridate::now())
x <- 10
x |> rnorm
x |> rnorm()
x |> rnorm(mean = 1)
x |> rnorm(mean = 1, sd = 2)
x |> rnorm(10, sd = 2)
sapply(1:10, \(x) rnorm(x, 1, 2))
install.packages("car")
install.packages("stringi")
install.packages("FDX")
install.packages("devtools")
install.packages("DescTools")
install.packages("ggpubr")
install.packages("doParallel")
install.packages("qpdf")
devtools::check_win_release()
devtools::check_win_oldrelease()
devtools::check_win_devel()
remove.packages("zoo", lib="~/R/x86_64-pc-linux-gnu-library/4.1")
remove.packages("qpdf", lib="~/R/x86_64-pc-linux-gnu-library/4.1")
remove.packages("lmtest", lib="~/R/x86_64-pc-linux-gnu-library/4.1")
rhub::check_on_solaris()
y <- 1:5 + rnorm(5, 0, 0.1)
x <- 0:4
lm(y ~ x)
x2 <- x - 2
sd(x)
sd(x2)
x3 <- x2/sd(x)
lm(y ~ x2)
mean(x)
lm(y ~ x3)
rhub::check_with_valgrind(show_status = FALSE)
rhub::check_with_sanitizers(show_status = FALSE)
rhub::check_for_cran(show_status = FALSE)
devtools::release()
file.exists("~/.ssh/id_rsa.pub")
devtools::install_github("iqm15/online_superunif_mt/tree/main/OnlineSuperUnif")
devtools::install_github("iqm15/online_superunif_mt", subdir = "tree/main/OnlineSuperUnif")
help(install_github)
devtools::install_github("iqm15/online_superunif_mt/OnlineSuperUnif")
devtools::install_github("iqm15/online_superunif_mt/OnlineSuperUnif/")
